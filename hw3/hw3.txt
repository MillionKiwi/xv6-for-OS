전체 완성

주요작업 내용
semaphore.c
enqueue: for 문을 돌면서 -1(초기값)인 경우 해당 index에 waiting할 pid를 넣어 주었습니다.
dequeue: 가장 처음에 들어온 값(index가 0)을 waker에 저장 후 for문을 통해 나머지 부분을 한
칸씩 옮겨주었고 이후 waker를 return 하였습니다.
sem_wait: num 범위가 맞는 지 확인하고 그러지 않을 경우 return -1하였습니다. 이후 lock을 얻고
value를 감소하였습니다. 이때,value < 0일 경우 enqueue하고 block하였습니다. 마지막으로 lock을
풀어주었습니다.
sem_signal: num 범위를 확인하고 lock을 얻고 value를 증가하였습니다. 이때,value =< 0일 경우 
dequeue하고 wakeup해주었습니다. 마지막으로 lock을 풀어주었습니다.

procon.c
main: process와 consumer 함수를 각각 2개씩 hufs_thread_create을 사용하여 선언하고 hufs_thread_join
으로 4개의 thread가 종료되길 기다렸습니다.
producer/consumer: 우선 while문을 통해 10000개의 data를 생성/소비 할수 있게 했습니다. 이후 producer에서는 empty
를 wait고 full을 signal하고 consumer에서는 그 반대가 되도록 하였습니다. 또한 critical session은 mutex로 보호하였
습니다. while문 중에서 생성해야할 남은 data 수가 1이하일 때(다른 프로세스가 남은 하나를 처리하고 있으므로) while문을
나가도록 하였습니다. 이후 mutex를 활용하여 4개의 thread 중 먼저 완료한 thread가 각각 p1, c1이 되도록 하였습니다.

producer, consumer, main 모두 exit()을 해야 에러가 발생하지 않았습니다.

결과 화면
$ proc_sem 5 10
Running with 5 processes...
Process started...
Process started...
Process started...
Process started...
Process started...
Final counter is 50, target is 50
TEST PASSED!

$ thread_sem 5 15
main: running with 5 threads...
main: created thread with pid 27
main: created thread with pid 28
main: created thread with pid 29
main: created thread with pid 30
main: created thread with pid 31
before joining... 
thread 0: started...
main: thread 27 joined...
thread 1: started...
thread 2: started...
thread 3: started...
thread 4: started...
before joining... 
main: thread 28 joined...
before joining... 
main: thread 29 joined...
before joining... 
main: thread 30 joined...
before joining... 
main: thread 31 joined...
Final counter is 75, target is 75
TEST PASSED!

$ procon
producer(1): 4995 produced
producer(2): 5005 produced
consumer(1): 5001 consumed
consumer(2): 4999 consumed

정상적으로 작동함을 확인할 수 있었습니다.